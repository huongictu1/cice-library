Lazy Loading: Chia nhỏ các module và chỉ tải chúng khi cần thiết. Điều này giúp giảm thời gian tải ban đầu của ứng dụng.
Optimize Bundle Size:
Sử dụng Tree Shaking để loại bỏ các mã không sử dụng trong gói cuối cùng.
Sử dụng Webpack Bundle Analyzer để xác định và loại bỏ các thư viện nặng hoặc không cần thiết.
Server-side Rendering (SSR) với Angular Universal: Điều này có thể cải thiện đáng kể thời gian tải trang bằng cách phục vụ HTML và CSS trước, trước khi JavaScript được tải và thực thi.
Change Detection Optimization: Angular sử dụng cơ chế kiểm tra thay đổi để cập nhật UI khi dữ liệu thay đổi. Bạn có thể tối ưu hóa điều này bằng cách sử dụng ChangeDetectionStrategy.OnPush trong các component để giảm số lần kiểm tra thay đổi.
TrackBy Function: Khi sử dụng các vòng lặp *ngFor, hãy sử dụng trackBy để chỉ định một hàm cho Angular biết làm thế nào để xác định các mục trong danh sách. Điều này giúp tăng hiệu suất khi cập nhật danh sách.
Caching and Service Workers: Sử dụng các công nghệ như Service Workers để lưu trữ các tài nguyên trên trình duyệt người dùng, giúp cải thiện thời gian tải khi người dùng quay trở lại trang web.
Optimize Images and Assets: Nén và tối ưu hóa hình ảnh và các tài sản khác để giảm kích thước tải về.
HTTP Requests Optimization: Giảm số lượng và kích thước của các yêu cầu HTTP, sử dụng kỹ thuật như Lazy Loading, Caching, hoặc GraphQL để chỉ tải dữ liệu cần thiết.
Use of Interceptors: Sử dụng các interceptors trong Angular để quản lý và tối ưu hóa các yêu cầu HTTP, ví dụ như nén dữ liệu hoặc thêm headers cache.
AOT Compilation: Sử dụng Ahead-of-Time (AOT) compilation để biên dịch các templates Angular thành JavaScript ngay trong quá trình xây dựng thay vì tại thời điểm chạy, giúp cải thiện hiệu suất.
Bắt đầu với một số bước này có thể giúp bạn cải thiện đáng kể thời gian tải và hiệu suất của ứng dụng Angular. Hãy xem xét từng phần và áp dụng phù hợp với trường hợp sử dụng của bạn.





1. Lazy Loading
Trong Angular, bạn có thể thiết lập lazy loading cho các module nhất định thông qua routing. Giả sử bạn có một module gọi là FeatureModule mà bạn muốn load một cách lười biếng:
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [
  {
    path: 'feature',
    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}
2. Optimize Bundle Size
Webpack Bundle Analyzer: Cài đặt và cấu hình webpack-bundle-analyzer để phân tích gói.
Tree Shaking: Đảm bảo rằng bạn đang sử dụng các phiên bản sản xuất khi xây dựng ứng dụng của mình để tận dụng tree shaking.
3. Server-side Rendering (SSR) với Angular Universal
Thêm Angular Universal vào ứng dụng của bạn:
ng add @nguniversal/express-engine
Sau khi cài đặt, bạn có thể xây dựng và chạy server-side của ứng dụng:
npm run build:ssr && npm run serve:ssr
4. Change Detection Optimization
Trong các component, bạn có thể cấu hình ChangeDetectionStrategy thành OnPush:
import { Component, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'app-my-component',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `...`
})
export class MyComponent {}
5. TrackBy Function
Sử dụng trackBy trong *ngFor để tối ưu hóa hiệu suất:
import { Component } from '@angular/core';

@Component({
  selector: 'app-my-list',
  template: `
    <div *ngFor="let item of items; trackBy: trackByFn">{{ item.name }}</div>
  `
})
export class MyListComponent {
  items = [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }];

  trackByFn(index, item) {
    return item.id; // or index
  }
}
6. Caching and Service Workers
Thêm Service Worker vào ứng dụng Angular của bạn:
ng add @angular/pwa
Cấu hình các tài nguyên được lưu trữ trong ngsw-config.json.

7. Optimize Images and Assets
Sử dụng các công cụ trực tuyến để nén hình ảnh trước khi tải lên dự án của bạn, hoặc sử dụng các công cụ như imagemin trong quy trình làm việc.

8. HTTP Requests Optimization
Cài đặt và sử dụng GraphQL hoặc các kỹ thuật tương tự để giảm số lượng và kích thước của các yêu cầu HTTP:
// Ví dụ sử dụng Apollo Client cho GraphQL
import { Apollo } from 'apollo-angular';
import gql from 'graphql-tag';

const GET_DATA = gql`
  query GetData($type: String!) {
    data(type: $type) {
      id
      value
    }
  }
`;

@Component({
  selector: 'app-data-fetcher',
  template: `...`
})
export class DataFetcherComponent {
  constructor(private apollo: Apollo) {}

  fetchData(type: string) {
    this.apollo.query({
      query: GET_DATA,
      variables: { type: type }
    }).subscribe(result => console.log(result));
  }
}
9. Use of Interceptors
Thêm một HTTP interceptor để tối ưu hóa các yêu cầu:
import { Injectable } from '@angular/core';
import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class CacheInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const cachedResponse = this.getFromCache(req);
    return cachedResponse ? of(cachedResponse) : next.handle(req);
  }

  private getFromCache(req: HttpRequest<any>): HttpResponse<any> | undefined {
    // Thêm logic lấy dữ liệu từ cache
    return undefined;
  }
}
10. AOT Compilation
AOT được kích hoạt mặc định trong các phiên bản mới của Angular. Đảm bảo rằng bạn đang sử dụng phiên bản mới nhất và thiết lập này được giữ nguyên trong tập tin angular.json.